#!/usr/bin/env node
// Copyright (C) 2020 Damien Dart, <damiendart@pobox.com>.
// This file is distributed under the MIT licence. For more information,
// please refer to the accompanying "LICENCE" file.

/* eslint no-console: 0 global-require: 0 */
/* eslint-env node */

const fse = require('fs-extra');
const glob = require('util').promisify(require('glob'));
const path = require('path');
const processors = [
  require('./processors/JavaScriptProcessor'),
  require('./processors/SassProcessor'),
  require('./processors/SVGProcessor'),
  require('./processors/TwigProcessor'),
];

if (
  process.argv.length !== 4
  || process.argv.includes('--help')
  || process.argv.includes('-h')
) {
  const askingForHelp = process.argv.includes('--help')
    || process.argv.includes('-h');

  (askingForHelp ? console.log : console.error)(
    `"${path.basename(process.argv[1])}" is a real basic static site generator.
    Usage: ${path.basename(process.argv[1])} INPUT-DIRECTORY OUTPUT-DIRECTORY`
      .trim().replace(/\n {4}/g, '\n'),
  );
  process.exit(askingForHelp ? 0 : 1);
}

const configurationOptions = { contextModifier: (context) => context };
const inputDirectory = path.resolve(process.argv[2]);
const outputDirectory = path.resolve(process.argv[3]);
let writtenFilesCount = 0;

try {
  Object.assign(
    configurationOptions,
    // eslint-disable-next-line import/no-dynamic-require
    require(`${inputDirectory}/.buildstatic.conf`),
  );
} catch (e) {
  if (e.code === 'MODULE_NOT_FOUND') {
    console.error('[!] No ".buildstatic.conf.js" found in input directory');
  } else {
    console.error(
      `[✘] Unable to process "${inputDirectory}/.buildconfig.conf.js!`,
    );
    console.error(`\n${e.toString()}`);
    process.exit(1);
  }
}

glob('**/*', { cwd: inputDirectory, nodir: true })
  .then((files) => Promise.all(files.map((file) => {
    const applicableProcessors = processors.filter(
      (processor) => processor.INPUT_EXTENSION === path.extname(file),
    );

    if (applicableProcessors.length > 0) {
      return Promise.all(
        applicableProcessors.map((Processor) => {
          const inputFile = path.join(inputDirectory, file);
          const outputFile = path.join(outputDirectory, file)
            .replace(Processor.INPUT_EXTENSION, Processor.OUTPUT_EXTENSION);
          let processorContext = {
            inputFile: { name: inputFile },
            inputDirectory,
            outputFile: { name: outputFile },
            outputDirectory,
          };

          if (configurationOptions.contextModifier instanceof Function) {
            processorContext = configurationOptions.contextModifier(
              processorContext,
            );
          }

          return fse.mkdirs(path.dirname(outputFile))
            .then(() => fse.readFile(inputFile, 'utf8'))
            .then((contents) => Processor.process(contents, processorContext))
            .then((output) => fse.writeFile(outputFile, output))
            .then(() => {
              console.log(`[✔] Written "${outputFile}"`);
              writtenFilesCount += 1;
            })
            .catch((e) => {
              console.error(`[✘] Unable to write "${outputFile}"`);
              console.error(`\n${e.toString()}`);
              process.exit(1);
            });
        }),
      );
    }

    const outputFile = path.join(outputDirectory, file);

    return fse.copy(path.join(inputDirectory, file), outputFile)
      .then(() => {
        console.log(`[✔] Written "${outputFile}"`);
        writtenFilesCount += 1;
      })
      .catch((e) => {
        console.error(`[✘] Unable to write "${outputFile}"`);
        console.error(`\n${e.toString()}`);
        process.exit(1);
      });
  })))
  .then(() => {
    console.log(`\n${writtenFilesCount} file(s) written!`);
  })
  .catch((e) => {
    console.error('[✘] An error has occurred!');
    console.error(`\n${e.toString()}`);
    process.exit(1);
  });
